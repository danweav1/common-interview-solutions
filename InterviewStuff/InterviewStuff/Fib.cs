using System;
using System.Collections.Generic;

namespace InterviewStuff
{
    // --- Directions
    // Print out the n-th entry in the fibonacci series.
    // The fibonacci series is an ordering of numbers where
    // each number is the sum of the preceeding two.
    // For example, the sequence
    //  [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
    // forms the first ten entries of the fibonacci series.
    // Example:
    //   fib(4) === 3
    public static class Fib
    {
        // SOLUTION 1 - Iterative Solution - for every increase in n, we have to calculate one additional number. As n increased by 1, we do one more calculation
        // and that will never change, so it's linear run time. Also, it's a single for loop always incrementing by 1, so O(n).
        // function fib(n) {
        // the trick is to recongize the first two numbers can't be generated by a for loop. We always know it's going to be 0 and 1.
        // so best way is to manually insert them into the results set.
        public static int DoFib1(int n)
        {
            List<int> result = new List<int>() { 0, 1 };

            // we start looping at the third element
            for (int i = 2; i <= n; i++)
            {
                int a = result[i - 1]; // can also do result[result.length - 1] to get previous record
                int b = result[i - 2];
                result.Add(a + b);
            }

            return result[n]; // return the last entry. could also do result[result.length - 1]
        }

        // // SOLUTION 2 - Recursive Solution - basically a bunch of 1's and 0's will be returned and added up to give the number we need
        // // For example, if n = 6, 1 will be returned 8 times. The 6th element of the fib sequence is 8.
        // // This is exponential time: 2^n. For each additional element, we are experience a dramatic increase in number of function calls required.
        // // This is a no no. Other solution is better.

        // // If you look at the function calls, many are being repeated. For instance when n =  6, fib(3) is being called 3 times.
        // // If interview asks you if there's someway to improve it, the answer is yes: memoization (solution further down)
        public static int DoFib2(int n)
        {
            if (n < 2)
            {
                return n;
            }

            return DoFib2(n - 1) + DoFib2(n - 2);
        }

        // SOLUTION 3 - no array used, no recursion
        public static int DoFib3(int n)
        {
            int current = 1;
            int oneBack = 0;

            for (int i = 1; i < n; i++)
            {
                current += oneBack;
                oneBack = current - oneBack;
            }

            return current;
        }

        // SOLUTION 4 - another type of recursion solution
        public static int DoFib4(int n, int init = 0, int last = 1, int count = 1)
        {
            if (n == count)
            {
                return last;
            }
            else
            {
                count++;
                return DoFib4(n, last, init + last, count);
            }
        }

        // SOLUTION 5 - using memoization. This uses caching arguments we've already passed.
        public static Func<T, TResult> Memoize<T, TResult>(this Func<T, TResult> func)
        {
            var t = new Dictionary<T, TResult>();

            return n =>
            {
                if (t.ContainsKey(n)) return t[n];

                var result = func(n);

                t.Add(n, result);

                return result;
            };
        }

        public static int DoFib5(int n)
        {
            return n <= 2 ? 1 : DoFib5(n - 2) + DoFib5(n - 1);
        }
    }
}
